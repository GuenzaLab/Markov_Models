!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
! CALCULATE COUNT MATRIX
!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!

SUBROUTINE C_MATRIX(C, dtrj, time, lag, nSim, nStates, maxtime)

!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
  !  VARIABLES
!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!

  IMPLICIT NONE
  INTEGER(kind=8),INTENT(in) :: lag, nSim, nStates, maxtime
  INTEGER(kind=8),INTENT(in) :: time(0:nSim-1)
  INTEGER(kind=8),INTENT(in) :: dtrj(0:maxtime-1,0:nSim-1)
  INTEGER(kind=8),INTENT(inout) :: C(1:nStates,1:nStates)

  INTEGER(kind=8) :: n,t

!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
  !  BUILD COUNT MATRIX
!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
  ! The transition matrix is built by counting the nubmer of events between states
  ! i to j.

  C = 0
  DO n=0,nSim-1
     DO t=0,time(n)-(lag+1)
        IF((t+lag)<=(time(n)-1))THEN
           C(dtrj(t,n),dtrj(t+lag,n))=C(dtrj(t,n),dtrj(t+lag,n))+1
        END IF
     END DO
  END DO
END SUBROUTINE C_MATRIX

!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
! CALCULATE COUNT MATRIX FROM MAP
!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!

SUBROUTINE C_MATRIX_MAP(C,trj0,trj1,map,time,lag,nSim,bins,nStates,maxtime)

!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
  !  VARIABLES
!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!

  IMPLICIT NONE
  INTEGER(kind=8),INTENT(in) :: lag,nSim,bins,nStates,maxtime
  INTEGER(kind=8),INTENT(in) :: map(0:bins-1,0:bins-1)
  INTEGER(kind=8),INTENT(in) :: time(0:nSim-1)
  INTEGER(kind=8),INTENT(in) :: trj0(0:maxtime-1,0:nSim-1)
  INTEGER(kind=8),INTENT(in) :: trj1(0:maxtime-1,0:nSim-1)
  INTEGER(kind=8),INTENT(inout) :: C(1:nStates,1:nStates)

  INTEGER(kind=8) :: n,t
  INTEGER(kind=8) :: Q(0:maxtime-1,0:nSim-1)

!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
  !  BUILD TIME DEPENDENT STATES
!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!

  DO n=0,nSim-1
     DO t=0,time(n)-1
        Q(t,n) = map(trj1(t,n),trj0(t,n))
     END DO
  END DO

!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
  !  BUILD COUNT MATRIX
!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
  ! The transition matrix is built by counting the nubmer of events between states
  ! i to j.

  C = 0
  DO n=0,nSim-1
     DO t=0,time(n)-(lag+1)
        IF((t+lag)<=(time(n)-1))THEN
           C(Q(t,n),Q(t+lag,n))=C(Q(t,n),Q(t+lag,n))+1
        END IF
     END DO
  END DO
END SUBROUTINE C_MATRIX_MAP

!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
! CALCULATE TRANSITION MATRIX AND DO NOT ENFORCE REVERSIBILITY
!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!

SUBROUTINE T_MATRIX_NREV(Tm, dtrj, time, lag, nSim, nStates, maxtime)

!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
  !  VARIABLES
!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!

  IMPLICIT NONE
  INTEGER(kind=8),INTENT(in) :: lag, nSim, nStates, maxtime
  INTEGER(kind=8),INTENT(in) :: dtrj(0:maxtime-1,0:nSim-1)
  INTEGER(kind=8),INTENT(in) :: time(0:nSim-1)
  DOUBLE PRECISION,INTENT(inout) :: Tm(1:nStates,1:nStates)

  INTEGER(kind=8) :: C(1:nStates,1:nStates)

  CALL C_MATRIX(C, dtrj, time, lag, nSim, nStates, maxtime)
  CALL NORMALIZE(Tm,C,nStates,"N")
END SUBROUTINE T_MATRIX_NREV

!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
! CALCULATE TRANSITION MATRIX AND ENFORCE REVERSIBILITY
!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
! This code calculates the transition matrix, for nSim simulations, using the
! states that are generated by K-Mediods clustering.
!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!

SUBROUTINE T_MATRIX_REV(Tm, dtrj, time, lag, nSim, nStates, maxtime)

!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
  !  VARIABLES
!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!

  IMPLICIT NONE
  INTEGER(kind=8),INTENT(in) :: lag, nSim, nStates, maxtime
  INTEGER(kind=8),INTENT(in) :: dtrj(0:maxtime-1,0:nSim-1)
  INTEGER(kind=8),INTENT(in) :: time(0:nSim-1)
  DOUBLE PRECISION,INTENT(inout) :: Tm(1:nStates,1:nStates)

  INTEGER(kind=8) :: C(1:nStates,1:nStates)

  CALL C_MATRIX(C, dtrj, time, lag, nSim, nStates, maxtime)
  CALL NORMALIZE(Tm,C,nStates,"Y")
END SUBROUTINE T_MATRIX_REV

!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
! CALCULATE TRANSITION MATRIX FROM MAP AND DO NOT ENFORCE REVERSIBILITY
!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!

SUBROUTINE T_MATRIX_NREV_MAP(Tm,trj0,trj1,map,time,lag,nSim,bins,nStates,maxtime)

!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
  !  VARIABLES
!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!

  IMPLICIT NONE
  INTEGER(kind=8),INTENT(in) :: maxtime
  INTEGER(kind=8),INTENT(in) :: lag,nSim,bins,nStates
  INTEGER(kind=8),INTENT(in) :: map(0:bins-1,0:bins-1)
  INTEGER(kind=8),INTENT(in) :: time(0:nSim-1)
  INTEGER(kind=8),INTENT(in) :: trj0(0:maxtime-1,0:nSim-1)
  INTEGER(kind=8),INTENT(in) :: trj1(0:maxtime-1,0:nSim-1)
  DOUBLE PRECISION,INTENT(inout) :: Tm(1:nStates,1:nStates)

  INTEGER(kind=8) :: C(1:nStates,1:nStates)

  CALL C_MATRIX_MAP(C,trj0,trj1,map,time,lag,nSim,bins,nStates,maxtime)
  CALL NORMALIZE(Tm,C,nStates,"N")
END SUBROUTINE T_MATRIX_NREV_MAP

!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
! CALCULATE TRANSITION MATRIX FROM MAP AND ENFORCE REVERSIBILITY
!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!

SUBROUTINE T_MATRIX_REV_MAP(Tm,trj0,trj1,map,time,lag,nSim,bins,nStates,maxtime)

!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
  !  VARIABLES
!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!

  IMPLICIT NONE
  INTEGER(kind=8),INTENT(in) :: maxtime
  INTEGER(kind=8),INTENT(in) :: lag,nSim,bins,nStates
  INTEGER(kind=8),INTENT(in) :: map(0:bins-1,0:bins-1)
  INTEGER(kind=8),INTENT(in) :: time(0:nSim-1)
  INTEGER(kind=8),INTENT(in) :: trj0(0:maxtime-1,0:nSim-1)
  INTEGER(kind=8),INTENT(in) :: trj1(0:maxtime-1,0:nSim-1)
  DOUBLE PRECISION,INTENT(inout) :: Tm(1:nStates,1:nStates)

  INTEGER(kind=8) :: C(1:nStates,1:nStates)

  CALL C_MATRIX_MAP(C,trj0,trj1,map,time,lag,nSim,bins,nStates,maxtime)
  CALL NORMALIZE(Tm,C,nStates,"Y")
END SUBROUTINE T_MATRIX_REV_MAP


!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
! CALCULATE STATIONARY DISTRIBUTION OF TRANSITION MATRIX
!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!

SUBROUTINE STATIONARY_DISTRIBUTION(pivec,Tm,nStates)
  IMPLICIT NONE
  INTEGER(KIND=8),INTENT(in) :: nStates
  DOUBLE PRECISION,INTENT(in) :: Tm(1:nStates,1:nStates)
  DOUBLE PRECISION,INTENT(inout) :: pivec(1:nStates)

  INTEGER(kind=8) :: i,INFO,LWORK,maxeig(1),order(1:nStates)
  DOUBLE PRECISION :: WR(1:nStates), WI(1:nStates), VL(1:nStates,1:nStates), &
       & WORK(nStates*nStates), VR(1:nStates,1:nStates)

  WORK = 0
  LWORK = -1
  ! Diagonalize transition matrix T
  CALL DGEEV("V","N",nStates,Tm,nStates,WR,WI,VL,nStates,VR,nStates,WORK,LWORK,INFO)

  ! Order eigenvalues
  DO i=1,nStates
    maxeig = MAXLOC(ABS(WR))
    order(i) = maxeig(1)
    WR(order(i)) = 1D-20
  END DO

  ! Assign first column vector to stationary distribution
  DO i=1,nStates
    pivec(i) = ABS(VL(order(1),i))/SUM(ABS(VL(order(1),:)))
  END DO
  !WRITE(*,*),pivec,INFO
END SUBROUTINE STATIONARY_DISTRIBUTION

!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
! NORMALIZE COUNT MATRIX AND RETURN TRANSITION MATRIX
!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
SUBROUTINE NORMALIZE(Tm,C,nStates,REV)
  IMPLICIT NONE
  CHARACTER(1),INTENT(in) :: REV
  INTEGER(kind=8),INTENT(in) :: nStates
  INTEGER(kind=8),INTENT(in) :: C(1:nStates,1:nStates)
  DOUBLE PRECISION,INTENT(inout) :: Tm(1:nStates,1:nStates)

  INTEGER(kind=8) :: i,j
  DOUBLE PRECISION :: Cr(1:nStates,1:nStates),weight(1:nStates)

  ! Symmetrize count matrix Cr
  DO i=1,nStates
    DO j=1,nStates
      IF(REV=="Y")THEN
        Cr(i,j) = (DBLE(C(i,j))+DBLE(C(j,i)))/2
      ELSE IF(REV=="N")THEN
        Cr(i,j) = C(i,j)
      END IF
    END DO
  END DO

  ! Build weights
  DO j=1,nStates
    weight(j) = 0
    DO i=1,nStates
       weight(j)=weight(j)+Cr(i,j)
    END DO
  END DO

  ! Build transition matrix T
  DO j=1,nStates
    DO i=1,nStates
       IF(weight(j)/=0)THEN
          Tm(i,j)=DBLE(Cr(i,j))/DBLE(weight(j))
       ELSE
          Tm(i,j)=0.d0
       END IF
    END DO
  END DO
END SUBROUTINE NORMALIZE

!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
! COARSE GRAIN DTRAJ
!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!

SUBROUTINE ASSIGNMENT(dtraj_out,dtraj_in,sets,nStates,nSamples)
  IMPLICIT NONE
  INTEGER(kind=8),INTENT(in) :: nStates,nSamples
  INTEGER(kind=8),INTENT(in) :: dtraj_in(1:nSamples), sets(1:nStates)
  INTEGER(kind=8),INTENT(inout) :: dtraj_out(1:nSamples)
  INTEGER(kind=8) :: t

  DO t=1,nSamples
    dtraj_out(t) = sets(dtraj_in(t)) - 1
  END DO
END SUBROUTINE ASSIGNMENT
